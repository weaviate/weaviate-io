---
title: 'Weaviate Authentication & Authorization: A Complete Security Guide'
slug: weaviate-security-authn-authz
authors: [dirk, ivan]
date: 2026-02-10
tags: ['security', 'authentication', 'authorization']
image: ./img/hero.png
description: 'Learn how to secure your Weaviate vector database with API keys, OIDC, and role-based access control (RBAC). Includes practical examples and setup steps.'
---

![Authentication & Authorization](./img/hero.png)

We've all heard the database horror stories. An intern accidentally exposes a customer's personally identifying information (PII) through a search API. An agentic application deletes an entire database in production. What starts as a simple oversight can quickly become a security incident, a compliance violation, or worse—a headline.

Much of this can be prevented by having the right security setup. This means knowing who is accessing the database (**authentication**), and only giving appropriate, predefined access to that user (**authorization**).

As vector databases move from prototype to production, often containing embeddings of sensitive customer data, proprietary documents, or regulated information, getting security right isn't optional. Whether you're a solo developer building your first AI application or a growing team preparing for production, understanding Weaviate's authentication and authorization options is essential.

In this guide, we'll explore what authentication and authorization mean in practice, what options Weaviate provides, and how to implement them for your use case.

## Why Access Control Matters

Just like traditional databases, access control is a critical part of the guardrails that protect a vector database. A collection containing product information should be treated differently from one containing customer service conversations, and anything containing PII must meet security and compliance requirements.

This is where the **_principle of least privilege_** becomes essential. This principle means users and applications should only have the exact access level required for them to do their job. A search API should be able to read product information (but not write), and a data scientist may access development data (but not production).

Two complementary mechanisms are essential to meet this goal:

- **Authentication** verifies the user's identity
- **Authorization** specifies what that user can do, based on their identity

### Authentication vs. Authorization

Put simply: authentication answers *"who are you?"* while authorization answers *"what are you allowed to do?"*. You need both—authentication without authorization means everyone who logs in gets full access, and authorization without authentication means you can't reliably enforce any rules. The rest of this guide covers how Weaviate implements each.

## Authentication in Weaviate: Verifying Identity

Weaviate offers several authentication options for different security requirements. Let's explore each one and when you might use them.

![Authentication methods in Weaviate](./img/weaviate-authentication-methods.png)

### Anonymous Access

Weaviate supports anonymous access, where no authentication is required to access the database.

:::caution ⚠️ Use with extreme caution

Anonymous access should only be used in local development environments. Never use anonymous access in production or with any data that requires protection.

:::

### API Key Authentication

API key authentication provides a straightforward way to verify that requests come from legitimate sources. Each API key is associated with a user identity in Weaviate, allowing you to track who's making requests and apply appropriate permissions. Here's an example of API key authentication through a Docker Compose configuration:

```yaml
services:
  weaviate:
    ...
    environment:
      ...
      # Example authentication configuration using API keys
      AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED: 'false'
      AUTHENTICATION_APIKEY_ENABLED: 'true'
      AUTHENTICATION_APIKEY_ALLOWED_KEYS: 'user-a-key,user-b-key'
      AUTHENTICATION_APIKEY_USERS: 'user-a,user-b'
```

**When to use it:**

- You're getting started with Weaviate and need simple, effective security
- You're building applications that need programmatic access
- You want to create service accounts for different applications or services
- You're using Weaviate Shared Cloud (where API key auth is pre-configured)

API keys work well for many production scenarios, especially when combined with [role-based access control](#role-based-access-control-rbac).

### OIDC - Identity Provider (IdP) Integration

For teams with existing identity infrastructure, Weaviate integrates with third-party identity providers through [OpenID Connect (OIDC)](https://docs.weaviate.io/deploy/configuration/authentication#oidc-authentication). This includes popular providers like Okta, Auth0, Azure AD, and Google Workspace, as well as self-hosted solutions like Keycloak or Authentik.

IdP integration offers several advantages:

**For administrators:**

- Centralized user management in one tool
- Leverage specialized, highly secure identity platforms
- Reduced attack surface—fewer systems to secure
- Existing access policies and multi-factor authentication carry over

**For users:**

- One fewer set of credentials to manage
- Familiar login experience
- Single sign-on (SSO) across your organization's tools

A key feature of IdP integration is that user credentials are never sent to Weaviate. Instead, the user authenticates against the IdP, which generates a JSON Web Token (JWT) for use with Weaviate. This token has far more limited scope than the original credentials, reducing risk for everyone involved.

**When to use it:**

- Your organization already uses an identity provider (Okta, Auth0, Azure AD, etc.)
- You need single sign-on (SSO) across your tooling
- You're operating in a regulated environment that requires centralized identity management
- You want multi-factor authentication (MFA) without building it yourself

:::tip

For enterprise-scale IdP integration, OIDC groups, and advanced SSO features, check out the [Weaviate OIDC authentication documentation](https://docs.weaviate.io/deploy/configuration/authentication#oidc-authentication).

:::

## Authorization in Weaviate: Controlling Access

Once a user is authenticated, authorization determines what they can do. Weaviate provides flexible authorization options ranging from simple to sophisticated.

![Authorization methods in Weaviate](./img/weaviate-authorization-methods.png)

### Admin List

Admin list is the simplest authorization model — it assigns users as either admins (full access) or read-only viewers. It can be configured using environment variables, as shown in the following Docker Compose example:

**When to use it:**

- You have a small team with simple access needs
- You're getting started and want quick, basic authorization
- You only need two levels of access: full admin or read-only

```yaml
services:
  weaviate:
    ...
    environment:
      ...
      # Example authentication configuration using API keys
      # (OIDC authentication can also be used with admin list or RBAC)
      AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED: 'false'
      AUTHENTICATION_APIKEY_ENABLED: 'true'
      AUTHENTICATION_APIKEY_ALLOWED_KEYS: 'user-a-key,user-b-key'
      AUTHENTICATION_APIKEY_USERS: 'user-a,user-b'

      # Authorization configuration
      # Enable admin list
      AUTHORIZATION_ADMINLIST_ENABLED: 'true'

      # Provide pre-configured roles to users
      # This assumes that the relevant user has been authenticated and identified
      #
      # You MUST define at least one admin user
      AUTHORIZATION_ADMINLIST_USERS: 'user-a'
      AUTHORIZATION_ADMINLIST_READONLY_USERS: 'user-b'
```

This configuration enables admin list authorization, giving `user-a` full admin permissions and `user-b` read-only viewer permissions.

However, most production use cases benefit from more granular control.

### Role-Based Access Control (RBAC)

RBAC lets you define precisely what each user or application can do. It works by assigning roles to users, where each role defines specific permissions for specific resources.

**When to use it:**

- You need more than just "admin" and "read-only" access levels
- Different users or services need access to different collections
- You want to enforce the principle of least privilege
- You're preparing for production or operating in a regulated environment

**How RBAC Works:**

- **Users** are assigned specific roles.
- **Roles** are containers for permissions (e.g., `Administrator`, `DataScientist`, `SearchApplication`)
- **Permissions** specify allowed actions on specific resources:
  - **Resources** include collections, tenants, roles, and other Weaviate objects
  - **Actions** include create, read, update, delete, and other operations

When a request comes in, Weaviate checks the user's role(s), evaluates their permissions for the requested operation, and either allows or denies access accordingly.

![RBAC diagram](./img/weaviate-rbac.png)

*RBAC structure showing how users inherit permissions through roles*

**Built-in Roles:**

Weaviate includes several built-in roles to get you started:

- `root`: Full access to everything—the database administrator
- `viewer`: Read-only access to everything—useful for analysts or auditors

**Custom Roles:**

For most real-world scenarios, you'll want to create custom roles tailored to your specific needs. Custom roles let you implement the principle of least privilege by granting exactly the permissions each user requires—nothing more, nothing less.

For example, you might create a `SearchApplication` role that can only read from your product catalog, or a `DataEngineer` role that can create and modify collections in development but only read from production.

## Practical Example: E-commerce Product Search

Let's see how authentication and authorization work together in a real-world scenario. Imagine you're running an e-commerce company using Weaviate to power product search, recommendations, and analytics.

You have three Weaviate collections:

- **`Products`**: Product descriptions and metadata
- **`CustomerBehavior`**: Purchase history, browsing patterns, interaction data (includes PII)
- **`InternalAnalytics`**: Business metrics, operational data

You define three custom roles with these permissions:

| Role                  | `Products`  | `CustomerBehavior` | `InternalAnalytics` | Collections for development |
| --------------------- | ----------- | ------------------ | ------------------- | --------------------------- |
| **Administrator**     | Full access | Full access        | Full access         | Full access                 |
| **DataScientist**     | Read only   | Read only          | Read only           | Full access                 |
| **SearchApplication** | Read only   | No access          | No access           | No access                   |

Below are some real-world scenarios that demonstrate how our security setup works:

**1. Product Searches**

When a customer searches for "wireless headphones" on your website, the search service authenticates with its API key as `searchapp`, which has the `SearchApplication` role. This role can query the `Products` collection but has no access to customer behavior or analytics data. The search works perfectly, and sensitive data remains protected.

**2. Data Science Workflow**

Your data scientist needs to build a new recommendation model. They authenticate using their API key (associated with the `DataScientist` role) and can:

- Read production data from all collections to understand patterns
- Create new collections in the development environment to experiment
- Iterate and refine the model with full control in dev

But they cannot accidentally delete or modify production data — there is no need for them to have _write_ access to it.

**3. Protection Against Compromised Credentials**

A malicious actor compromises the search application's API key. They attempt to extract customer data from the `CustomerBehavior` collection. But the `SearchApplication` role has no access to that collection—Weaviate denies the request. The attack is discovered through audit logs, the compromised key is revoked, and a new one is issued. Customer data remained protected throughout.

This example shows how authentication (verifying it's really the search application, the data scientist, or an attacker) combines with authorization (determining what each identity can do) to create robust, layered security.

## Getting Started with Weaviate Security Setup

Ready to implement authentication and authorization in your Weaviate instance? Here's how to get started based on your deployment type.

### Weaviate Open Source

Open source Weaviate users have access to all the same authentication and authorization features, with the flexibility to configure everything exactly as needed.

1. **[Choose your authentication method](https://docs.weaviate.io/deploy/configuration/authentication)**: Configure authentication in your Weaviate configuration file or environment variables. Start with API keys for simplicity, move to IdP integration as you grow
2. **[Define your roles](https://docs.weaviate.io/weaviate/configuration/rbac/manage-roles)**: Think about the different types of access you need (read-only, read-write, admin)
3. **[Set permissions](https://docs.weaviate.io/weaviate/configuration/rbac/manage-roles#create-new-roles-with-permissions)**: For each role, specify exactly which collections and actions are allowed
4. **[Assign roles](https://docs.weaviate.io/weaviate/configuration/rbac/manage-users)**: Give each user or application the least privileged role that lets them do their job
5. **[Test access](https://docs.weaviate.io/weaviate/configuration/rbac/manage-roles#view-role-details)**: Verify that each role can do what it should—and can't do what it shouldn't
6. **[Monitor and refine](https://docs.weaviate.io/deploy/configuration/logging)**: Review access logs and adjust permissions as your needs evolve

### Weaviate Cloud

Shared Cloud instances come with API key authentication and customizable RBAC pre-configured. This means you get enterprise-grade security without operational overhead.

**What you can do:**

- Create custom roles with granular permissions
- Define exactly what each role can access
- Manage users and API keys through the console UI
- Assign roles to users programmatically via the API

This is optimal for teams getting started or running smaller production workloads.

:::info Weaviate Cloud Security

Check out the Weaviate Cloud [authentication](https://docs.weaviate.io/cloud/manage-clusters/authentication) and [authorization](https://docs.weaviate.io/cloud/manage-clusters/authorization) guides.

:::

## Conclusion

Authentication and authorization might seem like just another checkbox on the path to production, but they're fundamental to building secure, trustworthy applications. By verifying who's accessing your Weaviate instance (authentication) and controlling what they can do (authorization), you can prevent significant problems down the line. 

Start with the security model that fits your current needs:

- **Getting started?** Use [Weaviate Cloud](https://docs.weaviate.io/cloud) with API keys and basic RBAC
- **Growing team?** Add custom roles with granular permissions
- **Need flexibility?** Deploy open source with your preferred configuration
- **Enterprise requirements?** Check out the [Weaviate OIDC authentication documentation](https://docs.weaviate.io/deploy/configuration/authentication#oidc-authentication) for SSO, OIDC groups, and advanced features

The key is to implement security from the start and scale it as you grow. Weaviate gives you the tools to do exactly that.

## Learn More

- [Weaviate Authentication Documentation](https://docs.weaviate.io/deploy/configuration/authentication)
- [Weaviate Authorization Documentation](https://docs.weaviate.io/deploy/configuration/authorization)
- [Role-Based Access Control Guide](https://docs.weaviate.io/weaviate/configuration/rbac)
- [Weaviate Cloud Authorization](https://docs.weaviate.io/cloud/manage-clusters/authorization)

Get started with Weaviate Cloud's pre-configured security, or follow the open source setup guide to configure authentication and RBAC for your deployment.

import WhatsNext from '/_includes/what-next.mdx';

<WhatsNext />
