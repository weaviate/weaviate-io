---
title: Batch import
sidebar_position: 15
image: og/docs/howto.jpg
# tags: ['how-to', 'import']
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import FilteredTextBlock from '@site/src/components/Documentation/FilteredTextBlock';
import PyCode from '!!raw-loader!/_includes/code/howto/manage-data.import.py';
import PyCodeV3 from '!!raw-loader!/_includes/code/howto/manage-data.import-v3.py';
import TSCode from '!!raw-loader!/_includes/code/howto/manage-data.import.ts';
import JavaCode from '!!raw-loader!/_includes/code/howto/java/src/test/java/io/weaviate/docs/manage-data.import.java';
import GoCode from '!!raw-loader!/_includes/code/howto/go/docs/manage-data.import_test.go';

[Batch imports](../tutorials/import.md#to-batch-or-not-to-batch) are an [efficient](../api/rest/objects.md#objects-vs-batch) way to add multiple data objects and cross-references.


<details>
  <summary>Additional information</summary>

To create a bulk import job, follow these steps:

1. Initialize a batch object.
1. Add items to the batch object.
1. Ensure that the last batch is sent (flushed).

</details>

## Enable asynchronous indexing

To maximize import speed, consider enabling [asynchronous indexing](../configuration/indexes.md#asynchronous-indexing) and using gRPC batch imports. Asynchronous indexing is an experimental feature in `1.22`, and may not be suitable for production use.

To enable asynchronous indexing, set the `ASYNC_INDEXING` environment variable to `true` in your Weaviate configuration file.

```yaml
weaviate:
  image: semitechnologies/weaviate:||site.weaviate_version||
  ...
  environment:
    ASYNC_INDEXING: 'true'
  ...
```
## Enable gRPC batch imports

The easiest way to use gRPC batch imports is to use the [Python client `v4`](../client-libraries/python.md). If you cannot use the new client, access the [gRPC API directly](../api/grpc.md).

## Basic batch import example

The following example will add objects to `YourName` collection using a batch import.

<Tabs groupId="languages">
  <TabItem value="py" label="Python (v4)">
    <FilteredTextBlock
      text={PyCode}
      startMarker="# BasicBatchImportExample"
      endMarker="# END BasicBatchImportExample"
      language="py"
    />
  </TabItem>

  <TabItem value="py3" label="Python (v3)">
    <FilteredTextBlock
      text={PyCodeV3}
      startMarker="# BasicBatchImportExample"
      endMarker="# END BasicBatchImportExample"
      language="py"
    />
  </TabItem>

  <TabItem value="js" label="JavaScript/TypeScript">
    <FilteredTextBlock
      text={TSCode}
      startMarker="// BasicBatchImportExample"
      endMarker="// END BasicBatchImportExample"
      language="ts"
    />
  </TabItem>

  <TabItem value="java" label="Java">
    <FilteredTextBlock
      text={JavaCode}
      startMarker="// BasicBatchImportExample"
      endMarker="// END BasicBatchImportExample"
      language="java"
    />
  </TabItem>

  <TabItem value="go" label="Go">
    <FilteredTextBlock
      text={GoCode}
      startMarker="// BasicBatchImportExample"
      endMarker="// END BasicBatchImportExample"
      language="go"
    />
  </TabItem>
</Tabs>

:::info Where is the collection definition?
In this example, if the collecion `YourName` does not already exist, it will be created by Weaviate with its [auto-schema](../configuration/schema-configuration.md#auto-schema) feature.
:::


## Optional object parameters

The following does not apply to cross-references.

### `id`

You can optionally specify a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) as the ID, or leave it blank to have Weaviate generate one. You can also use a deterministic UUID (UUIDv5) as shown here to [prevent duplicates](#managing-potential-duplication).

<Tabs groupId="languages">
  <TabItem value="py" label="Python (v4)">
    <FilteredTextBlock
      text={PyCode}
      startMarker="# BatchImportWithIDExample"
      endMarker="# END BatchImportWithIDExample"
      language="py"
    />
  </TabItem>

  <TabItem value="py3" label="Python (v3)">
    <FilteredTextBlock
      text={PyCodeV3}
      startMarker="# BatchImportWithIDExample"
      endMarker="# END BatchImportWithIDExample"
      language="py"
    />
  </TabItem>

  <TabItem value="js" label="JavaScript/TypeScript">
    <FilteredTextBlock
      text={TSCode}
      startMarker="// BatchImportWithIDExample"
      endMarker="// END BatchImportWithIDExample"
      language="ts"
    />
  </TabItem>

  <TabItem value="java" label="Java">
    <FilteredTextBlock
      text={JavaCode}
      startMarker="// BatchImportWithIDExample"
      endMarker="// END BatchImportWithIDExample"
      language="java"
    />
  </TabItem>

  <TabItem value="go" label="Go">
    <FilteredTextBlock
      text={GoCode}
      startMarker="// BatchImportWithIDExample"
      endMarker="// END BatchImportWithIDExample"
      language="go"
    />
  </TabItem>
</Tabs>

### `vector`

You can optionally specify a vector to represent each object. Otherwise, Weaviate will follow the relevant vectorizer setting.

<Tabs groupId="languages">
  <TabItem value="py" label="Python (v4)">
    <FilteredTextBlock
      text={PyCode}
      startMarker="# BatchImportWithVectorExample"
      endMarker="# END BatchImportWithVectorExample"
      language="py"
    />
  </TabItem>

  <TabItem value="py3" label="Python (v3)">
    <FilteredTextBlock
      text={PyCodeV3}
      startMarker="# BatchImportWithVectorExample"
      endMarker="# END BatchImportWithVectorExample"
      language="py"
    />
  </TabItem>

  <TabItem value="js" label="JavaScript/TypeScript">
    <FilteredTextBlock
      text={TSCode}
      startMarker="// BatchImportWithVectorExample"
      endMarker="// END BatchImportWithVectorExample"
      language="ts"
    />
  </TabItem>

  <TabItem value="java" label="Java">
    <FilteredTextBlock
      text={JavaCode}
      startMarker="// BatchImportWithVectorExample"
      endMarker="// END BatchImportWithVectorExample"
      language="java"
    />
  </TabItem>

  <TabItem value="go" label="Go">
    <FilteredTextBlock
      text={GoCode}
      startMarker="// BatchImportWithVectorExample"
      endMarker="// END BatchImportWithVectorExample"
      language="go"
    />
  </TabItem>
</Tabs>

## Batch parameters - Python client

We recommend using `client.batch` in a context manager as it will automatically flush the last batch when exiting.

### Set batch parameters

You can set batch parameters using the `client.batch.configure` function.

The following example specifies a batch size of 200 and parallelizes the import process with up to 2 threads:

<FilteredTextBlock
  text={PyCodeV3}
  startMarker="# ConfigureBatchImportExample"
  endMarker="# END ConfigureBatchImportExample"
  language="py"
/>


### Performance parameters

The following parameters will have the greatest impact on the batch import speed:
- `batch_size` (int) - the (initial) size of the batch
- `num_workers` (int) - the maximum number of parallel workers
- `dynamic` (bool) - whether to dynamically adjust the `batch_size` based on the number of items in the batch

We recommend starting with:
- `batch_size`: 50-200
- `num_workers`: 1-2,
- `dynamic`: `True` (if you are not sure what batch size to use)

Using these parameters, you can set dynamic or automatic batching:

<Tabs groupId="languages">
<TabItem value="auto" label="Automatic">

```python
with client.batch(
    batch_size=100,  # Specify the batch size
    num_workers=2,   # Parallelize the process
    # dynamic=False  # By default
) as batch:
# Add objects to batch
```

</TabItem>
<TabItem value="dynamic" label="Dynamic">

```python
with client.batch(
    batch_size=100,  # Specify the batch size
    num_workers=2,   # Parallelize the process
    dynamic=True,    # Weaviate will dynamically adjust the batch size
) as batch:
# Add objects to batch
```

</TabItem>
</Tabs>


### Error handling parameters

The following parameters will most impact error handling:
- `timeout_retries` (int) & `connection_error_retries` (int) - Batch-level numbers of retries
- `weaviate_error_retries` (int) - Object-level number of retries for an error originating from Weaviate (for example inference / transformer timeouts)
- `callback` - Call a function at the end of batching - for example to inspect the response
    - The default is `weaviate.util.check_batch_result`

For a complete list of batch parameters and details about the types of batching, see the [Python client batching](../client-libraries/python.md#batching) section.


## Batch parameters - other clients

At this point in time, the other clients do not support batch parameters, and manual flushing is required.


## Managing potential duplication

In Weaviate, the only unique field is the `id`. If you try to import an object with an existing id Weaviate will overwrite the object if one exists. (In [single-object creation](./create.mdx), Weaviate will throw an error if the `id` exists.)

To prevent duplicates, we suggest:
- Using a deterministic ID generation method.

With a deterministic ID, Weaviate will either be creating a new object or overwriting an existing one, depending on whether the object already exists.

### Generate deterministic ID

You can do so with the [`generate_uuid5`](https://weaviate-python-client.readthedocs.io/en/stable/weaviate.util.html#weaviate.util.generate_uuid5) function in the Python client, or the `generateUuid5` function in the TypeScript client. See the [`id` section above](#id) for a concrete example.

### Check if an object exists

You can [check if an object exists](./read.mdx#check-object-existence) given its [id](../api/graphql/additional-properties.md#id).

:::info IDs unique to each collection and tenants
[Collections](../concepts/data.md#class-collections) and [tenants](../concepts/data.md#multi-tenancy) each work like namespaces. So, it is possible to have the same id in different collections and/or tenants.
:::

## Tip: Stream data from large files

A good practice for importing large datasets is to stream the input file rather than risking running out of memory by loading it all at once. For Python, this can be achieved with libraries like [ijson](https://pypi.org/project/ijson/) for JSON files and [pandas for CSV files](https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html). For Node, a streams-based solution is presented below.

<!-- TODOv4: update Python - JSON and CSV with v4 code -->

<Tabs groupId="languages">
  <TabItem value="py" label="Python - JSON">

  <FilteredTextBlock
    text={PyCode}
    startMarker="# START JSON streaming"
    endMarker="# END JSON streaming"
    language="py"
  />

  </TabItem>
  <TabItem value="pycsv" label="Python - CSV">

  <FilteredTextBlock
    text={PyCode}
    startMarker="# START CSV streaming"
    endMarker="# END CSV streaming"
    language="py"
  />

  </TabItem>
  <TabItem value="js" label="TypeScript - JSON">

  <FilteredTextBlock
    text={TSCode}
    startMarker="// START JSON streaming"
    endMarker="// END JSON streaming"
    language="ts"
  />

  </TabItem>
  <TabItem value="jscsv" label="TypeScript - CSV">

  <FilteredTextBlock
    text={TSCode}
    startMarker="// START CSV streaming"
    endMarker="// END CSV streaming"
    language="ts"
  />

  </TabItem>
</Tabs>

## Related pages

- [How-to: Create objects](./create.mdx)
- [References: REST - /v1/batch](../api/rest/batch.md)
- [Configuration: Indexes](../configuration/indexes.md#asynchronous-indexing)

import DocsMoreResources from '/_includes/more-resources-docs.md';

<DocsMoreResources />
