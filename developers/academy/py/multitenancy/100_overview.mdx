---
title: "Multi-tenancy: Overview"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import FilteredTextBlock from '@site/src/components/Documentation/FilteredTextBlock';
import PyCode from '!!raw-loader!./_snippets/100_config.py';

In general, the term "multi-tenancy" refers to a software architecture where a single instance of the software serves multiple "tenants". Each tenant here is a group of users who share common access.

In Weaviate, multi-tenancy allows each collection to serve multiple, isolated tenants. Each "tenant" in a multi-tenant collection can only access their own data, while sharing the same data structure and settings.

![multi-tenancy](../../../../blog/2023-06-15-multi-tenancy/img/multi-tenancy-dark.png#gh-dark-mode-only)
![multi-tenancy](../../../../blog/2023-06-15-multi-tenancy/img/multi-tenancy-light.png#gh-light-mode-only)

This allows Weaviate to efficiently serve a large number of tenants with minimal overhead.

## <i class="fa-solid fa-square-chevron-right"></i> Why use multi-tenancy?

A typical multi-tenancy use-case is in a software-as-a-service (SaaS) application. In a SaaS application, each end user or account, may have their own data that should be only accessible to them.

Using single-tenant collections, you might implement this with:

1. **A monolithic collection**: To store the entire dataset, with an end user identifier property
1. **Per-end-user collections**: Where each end user's data would be in a separate collection

Unfortunately, neither of these are suitable.

1. **A monolithic collection** would be:
    - Inefficient, as each tenant's data would typically be a very small percentage of the collection.
    - Difficult to manage, as data isolation would be difficult to enforce.
1. **Per-end-user collection** would be:
    - Inefficient, as each collection incurs non-trivial overhead.
    - Difficult to manage, as each collection would need to be managed separately.

Multi-tenancy solves these problems.

### <i class="fa-solid fa-chalkboard"></i> Multi-tenancy benefits

Multi-tenancy allows you to build one collection with one set of configurations, AND it allows each tenant's data to be isolated from each other. This makes multi-tenancy resource-efficient, as well as much easier to manage.

Thanks to multi-tenancy's low overhead, a Weaviate node can serve thousands of active end users in a multi-tenant collection. Furthermore, each tenant's data is isolated from each other, eliminating risks of accidental data leakage and making it easier to manage.

### <i class="fa-solid fa-chalkboard"></i> Tenant activity status

Weaviate's multi-tenancy solution also includes a tenant activity status. This recognizes that some tenants may be more active than others, or may be likely to be active at certain times (e.g. due to time zones).

To reduce resource usage, non-active end users' data can be stored as a "cold" tenant. Cold tenants are offloaded from memory, and require virtually no overhead, which further frees up resources to serve active end users. These are called "hot" tenants.

## <i class="fa-solid fa-square-chevron-right"></i> Multi-tenancy implementation

Multi-tenancy is implemented in Weaviate as follows:

- A collection can be configured as multi-tenant at creation time.
    - This is immutable, and cannot be changed after creation.
- Tenants can be created and deleted at any time. Each tenant is isolated from each other.
- All tenants share the same settings, which are inherited from the collection.
- Each object in a multi-tenant collection must belong to a tenant.
- Each tenant has its own, isolated, indexes
- Deleting a tenant will delete all objects associated with that tenant.
- A tenant's activity status can be set to "hot" or "cold". This can be changed at any time.
    - "Cold" tenants are not accessible, and require no resources.

[Next](./200_manage.mdx), we will take a look at how to manage a multi-tenant collection.

## Questions and feedback

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>

