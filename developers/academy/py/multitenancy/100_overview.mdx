---
title: "Overview"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import FilteredTextBlock from '@site/src/components/Documentation/FilteredTextBlock';
import PyCode from '!!raw-loader!./_snippets/100_config.py';

In general, the term "multi-tenancy" refers to a software architecture where a single instance of the software serves multiple "tenants". Each tenant here is a group of users who share common access.

In Weaviate, multi-tenancy allows a collection to efficiently serve isolated groups of data. Each "tenant" in a multi-tenant collection can only access its own data, while sharing the same data structure and settings.

![multi-tenancy](../../../../blog/2023-06-15-multi-tenancy/img/multi-tenancy-dark.png#gh-dark-mode-only)
![multi-tenancy](../../../../blog/2023-06-15-multi-tenancy/img/multi-tenancy-light.png#gh-light-mode-only)

This allows Weaviate to efficiently serve a large number of tenants with minimal overhead.

## <i class="fa-solid fa-square-chevron-right"></i> Why use multi-tenancy?

A typical multi-tenancy use-case is in a software-as-a-service (SaaS) application. In many SaaS applications, each end user or account will have private data that should be not be accessible to anyone else.

Using single-tenant collections, you might implement this with:

1. **A monolithic collection**: To store the entire dataset, with an end user identifier property
1. **Per end-user collections**: Where each end user's data would be in a separate collection

While these may work to some extent, both of these options have significant limitations.

1. Using **a monolithic collection**:
    - Queries may be slower, as the collection must host all users' data.
    - For the same reason, deleting individual users' data is also difficult.
    - Accidental data exposure is possible, as data isn't inherently isolated.
1. Using **end-user-specific collections**:
    - Would be very resource-intensive, as a high number of collections will be required.
    - Administration overhead may be higher, as each collection-level operation (e.g. adding a new property) would need to be run separately.

Multi-tenancy solves these problems.

### <i class="fa-solid fa-chalkboard"></i> Benefits of multi-tenancy

In multi-tenant collection, each "tenant" can be thought of as an equivalent of a single-tenant collection.

Each tenant is isolated from each other, while sharing the same set of configurations.

This arrangement helps make multi-tenancy far more resource-efficient than using individual collections to store data for each user. A Weaviate node can thus serve far more tenants than it could single-tenant collections.

It also reduces administration overhead, as the collection configuration propagates down to each tenant. Furthermore, the data isolation eliminates risks of accidental data leakage and makes it significantly easier to delete user data upon request.

## <i class="fa-solid fa-square-chevron-right"></i> Similarities to collections

Each multi-tenant collection can have any number of tenants. Let's refer to the subset of a multi-tenant collection that belongs to a tenant as "tenant data".

Tenant data works very similarly to a single-tenant collection. For example:

| Aspect | Tenant data | Sigle-tenant collection |
| ----- | ----- | ----- |
| An object | Belongs to a tenant | Belong to a collection |
| Vector index | One per tenant | One per collection |
| Deletion | Deleting a tenant deletes all tenant data | Deleting a collection deletes all collection data |
| Query | Can search one tenant at a time | Can search one collection at a time |

### <i class="fa-solid fa-chalkboard"></i> Tenant activity status

Each tenant includes an activity status. This recognizes that although many users may be frequently active and access their data (i.e. tenant), not all users will share this pattern.

For example, some user may rarely log in, or only active at certain times (e.g. due to time zones). Others may even have been inactive for a long time.

Tenant activity status can help to reduce overhead required to support these infrequent users. The available tenant activity statuses are:

- `Active` (default) tenants are loaded in memory and its data is available for read/write operations.
- `Inactive` tenants are available on local disk, but not available for any read/write operations. This lowers Weaviate's memory footprint, while still allowing for quick access.
- `Offloaded` tenants are stored in a remote storage (e.g. AWS S3) and are not available for read/write operations. This is the most resource-efficient option, as it requires virtually no overhead.

## Questions and feedback

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>

