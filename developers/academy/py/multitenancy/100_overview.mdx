---
title: "Multi-tenancy: Overview"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import FilteredTextBlock from '@site/src/components/Documentation/FilteredTextBlock';
import PyCode from '!!raw-loader!./_snippets/100_config.py';

Multi-tenancy generally refers to a software architecture where a single instance of the software serves multiple "tenants". Each tenant is a group of users who share common access.

In Weaviate, multi-tenancy is implemented at the collection level. A collection can optionally be configured with multi-tenancy, such that each "tenant" can access only their own data. Each object in a multi-tenant collection will share the same settings such as vectorizer, index settings and properties.

The main difference is that objects in a multi-tenant collection are further divided into isolated "tenants".

![multi-tenancy](../../../../blog/2023-06-15-multi-tenancy/img/multi-tenancy-dark.png#gh-dark-mode-only)
![multi-tenancy](../../../../blog/2023-06-15-multi-tenancy/img/multi-tenancy-light.png#gh-light-mode-only)


## <i class="fa-solid fa-square-chevron-right"></i> Why use multi-tenancy?

One use of multi-tenancy is a software-as-a-service (SaaS) type application. In a SaaS application, each end user, or account, may have some data objects associated with it.

Using single-tenant collections, you might use:

1. **A monolithic collection**: To store the entire dataset, with an end user identifier property
1. **Per-end-user collection**: Where each end user's data would be in a separate collection

Unfortunately, neither of these are suitable.

1. **A monolithic collection** would be:
    - Inefficient, as each tenant's data would typically be a very small percentage of the collection.
    - Difficult to manage, as data isolation would be difficult to enforce.
1. **Per-end-user collection** would be:
    - Inefficient, as each collection incurs non-trivial overhead.
    - Difficult to manage, as each collection would need to be managed separately.

Multi-tenancy solves these problems.

### <i class="fa-solid fa-chalkboard"></i> Trade-offs

It allows you to build one collection with one set of configurations, but with each tenant's data isolated from each other. This is more efficient, and easier to manage.

Thanks to the low overhead, a Weaviate node can serve thousands of end users in a multi-tenant collection with very little resource overhead. Each tenant's data is isolated from each other, eliminating risks of accidental data leakage, and making it easier to manage.

Furthermore, non-active end users' data can be stored as a "cold" tenant. Cold tenants require virtually no overhead, which further frees up resources to serve active end users. These are called "hot" tenants.

## <i class="fa-solid fa-square-chevron-right"></i> Multi-tenancy implementation

Multi-tenancy is implemented in Weaviate as follows:

- A collection can be configured as multi-tenant at creation time.
    - This is immutable, and cannot be changed after creation.
- Tenants can be created and deleted at any time. Each tenant is isolated from each other.
- All tenants share the same settings, which are inherited from the collection.
- Each object in a multi-tenant collection must belong to a tenant.
- Each tenant has its own, isolated, indexes
- Deleting a tenant will delete all objects associated with that tenant.
- A tenant's activity status can be set to "hot" or "cold". This can be changed at any time.
    - "Cold" tenants are not accessible, and require no resources.

[Next](./200_manage.mdx), we will take a look at how to manage a multi-tenant collection.

## Questions and feedback

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>

