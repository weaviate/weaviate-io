---
title: Using a multi-tenant collection
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import FilteredTextBlock from '@site/src/components/Documentation/FilteredTextBlock';
import PyCode from '!!raw-loader!./_snippets/100_config.py';

Once a multi-tenant collection has been configured and tenants created, you can interact with each tenant's data very similarly to how you would with a single-tenant collection. This section will show you how to work with data in a multi-tenant collection.







You can `create`, `remove`, or `update` tenants at any point throughout a lifecycle of a collection. You can also check that a tenant `exists`, or get one or more tenants (`get`, `get_by_name`, `get_by_names`) for further operations.

#### Create tenants


#### `Tenant` class

Helper class stuff

## <i class="fa-solid fa-square-chevron-right"></i> Configuration options

### <i class="fa-solid fa-chalkboard"></i> Collection creation

You've seen that a multi-tenant collection must be specified as such at creation time. Additionally, you can specify one or more of `auto_tenant_creation` or `auto_tenant_activation` parameters for the collection.

<FilteredTextBlock
  text={PyCode}
  startMarker="# VerboseMTEnable"
  endMarker="# END VerboseMTEnable"
  language="py"
/>

<details>
  <summary>What is <code>auto_tenant_creation</code>?</summary>

:::info Added in `v1.25`
The auto tenant creation feature is available from `v1.25.0` for batch imports, and from `v1.25.2` for single object insertions.
:::

Enabling `auto_tenant_creation` will cause Weaviate to automatically create the tenant when an object is inserted against a non-existent tenant.

This option is particularly useful for bulk data ingestion, as it removes the need to create the tenant prior to object insertion. Instead, `auto_tenant_creation` will allow the object insertion process to continue without interruption.

A risk of using `auto_tenant_creation` is that an error in the source data will not be caught during import. For example, a source object with erroneously spelt `"TenntOn"` instead of `"TenantOne"` will create a new tenant for `"TenntOne"` instead of raising an error.

The server-side default for `auto_tenant_creation` is `false`.
</details>

<details>
  <summary>What is <code>auto_tenant_activation</code>?</summary>

:::info Added in `v1.25.2`
The auto tenant activation feature is available from `v1.25.2`.
:::

If `auto_tenant_activation` is enabled, Weaviate will automatically activate any deactivated (`INACTIVE` or `OFFLOADED`) tenants when they are accessed.

This option is particularly useful for scenarios where you have a large number of tenants, but only a subset of them are active at any given time. An example is a SaaS app where some tenants may be unlikely due to their local time zone, or their recent activity level.

By enabling `auto_tenant_activation`, you can safely set those less active users to be inactive, knowing that they will be loaded onto memory once requested.

This can help to reduce the memory footprint of your Weaviate instance, as only the active tenants are loaded into memory.

The server-side default for `auto_tenant_activation` is `false`.

</details>

#### Replication

Weaviate offers [data replication](../../../weaviate/concepts/replication-architecture/index.md#data-replication) options for fault tolerance.

This applies to tenants as well. Set the replication factor to your desired number (e.g. 3, 5, etc.) and Weaviate will create replicas of each tenant.

#### Sharding

Each tenant in Weaviate is a lightweight shard that will contain all of each tenant's objects. Accordingly, Weaviate's [sharding settings](/developers/weaviate/config-refs/schema/index.md#shardingconfig) such as the number of desired physical or virtual shards do not apply to multi-tenant collections.

### <i class="fa-solid fa-chalkboard"></i> Tenant creation

As discussed earlier, each tenant in a multi-tenant collection is isolated from each other. Each tenant in a multi-tenant collection acts as a separate collection, with its own data and indexes.

The only tenant-specific configuration is the tenant's activity status. The default tenant status is "ACTIVE".

#### Using tenant names

:::info Tenant names are case-sensitive
:::

Tenants can be created using the names only, as shown below.

<FilteredTextBlock
  text={PyCode}
  startMarker="# TenantCaseSensitivity"
  endMarker="# END TenantCaseSensitivity"
  language="py"
/>

Note that this creates two separate tenants.

#### Using the `Tenant` class

Tenants can also be created by using the `Tenant` helper class.

<FilteredTextBlock
  text={PyCode}
  startMarker="# TenantCreationWithStatus"
  endMarker="# END TenantCreationWithStatus"
  language="py"
/>

Note that a mix of strings and `Tenant` objects can be used to create tenants.

### <i class="fa-solid fa-chalkboard"></i> Tenant activity status

Each tenant includes an activity status. This recognizes that although many users may be frequently active and access their data (i.e. tenant), not all users will share this pattern.

For example, some user may rarely log in, or only active at certain times (e.g. due to time zones). Others may even have been inactive for a long time.

Tenant activity status can help to reduce overhead required to support these infrequent users. The available tenant activity statuses are:

- `Active` (default) tenants are loaded in memory and its data is available for read/write operations.
- `Inactive` tenants are available on local disk, but not available for any read/write operations. This lowers Weaviate's memory footprint, while still allowing for quick access.
- `Offloaded` tenants are stored in a remote storage (e.g. AWS S3) and are not available for read/write operations. This is the most resource-efficient option, as it requires virtually no overhead.

[Next up](./250_config_example.mdx), let's take a look at a concrete example.























## <i class="fa-solid fa-square-chevron-right"></i> Tenant-level data

In a single-tenant collection, you would interact with the collection directly. In a multi-tenant collection, you interact with a tenant-level subset of the collection, as shown below:

<FilteredTextBlock
  text={PyCode}
  startMarker="# GetTenantCollection"
  endMarker="# END GetTenantCollection"
  language="py"
/>

## <i class="fa-solid fa-square-chevron-right"></i> CRUD operations

## <i class="fa-solid fa-square-chevron-right"></i> Searches



## <i class="fa-solid fa-square-chevron-right"></i> Further resources



## Questions and feedback

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>

