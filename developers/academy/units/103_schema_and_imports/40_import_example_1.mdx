---
title: Data import - Example 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import FilteredTextBlock from '@site/src/components/Documentation/FilteredTextBlock';
import PythonCodeExample from '!!raw-loader!./snippets/40_import_example_1.py';

## <i class="fa-solid fa-square-chevron-right"></i>&nbsp;&nbsp;Overview

It's time to put what we've learned into action! In this section, we will:

- Download a small dataset,
- Build a schema corresponding to the dataset,
- Import it to our WCS instance, and
- Run a couple of queries.

### <i class="fa-solid fa-chalkboard"></i>&nbsp;&nbsp;Dataset used

We are going to use data from a popular and long-lasting quiz game show called *Jeopardy!*.

The original dataset can be found [here on Kaggle](https://www.kaggle.com/datasets/tunguz/200000-jeopardy-questions), but we'll use a [small subset from it, just containing 100 rows](https://raw.githubusercontent.com/weaviate-tutorials/edu-datasets/main/jeopardy_100.json).

Here's a preview of a few rows of data.

|    | Air Date   | Round            |   Value | Category         | Question                                                                                                             | Answer                                     |
|---:|:-----------|:-----------------|--------:|:-----------------|:---------------------------------------------------------------------------------------------------------------------|:-------------------------------------------|
|  0 | 2006-11-08 | Double Jeopardy! |     800 | AMERICAN HISTORY | Abraham Lincoln died across the street from this theatre on April 15, 1865                                           | Ford's Theatre (the Ford Theatre accepted) |
|  1 | 2005-11-18 | Jeopardy!        |     200 | RHYME TIME       | Any pigment on the wall so faded you can barely see it                                                               | faint paint                                |
|  2 | 1987-06-23 | Double Jeopardy! |     600 | AMERICAN HISTORY | After the original 13, this was the 1st state admitted to the union                                                  | Vermont                                    |

For now, let's keep it simple by populating Weaviate with just the `Round`, `Value`, `Question` and `Answer` columns.

:::note <i class="fa-solid fa-square-terminal"></i> Exercise
Can you remember what the next steps should be?
:::

## <i class="fa-solid fa-square-chevron-right"></i>&nbsp;&nbsp;Build a schema

The next step is to build a schema, making some decisions about how to represent our data in Weaviate.

### <i class="fa-solid fa-code"></i>&nbsp;&nbsp;Add class names & properties

First of all, we'll need a name. The name refers to each row or item (*note: singular*), so I called it `JeopardyQuestion`. Then, I need to define properties and types.

You saw above that we'll be populating Weaviate with `Round`, `Value`, `Question` and `Answer` columns. We need names for Weaviate `properties` - these names are sensible, but we follow the GraphQL convention of capitalizing classes and leaving properties as lowercases, so the names will be `round`, `value`, `question` and `answer`.

Then, we should select datatypes. All of `round`, `question` and `answer` are text, so we can simply choose `text` as our datatype. `value` is a number, but I know that values in *Jeopardy!* represent dollar amounts, meaning that they are always integers. So we'll use `int`.

<Tabs groupId="languages">
<TabItem value="py" label="Python">
<FilteredTextBlock
  text={PythonCodeExample}
  startMarker="# Class & property definitions"
  endMarker="# Specify a vectorizer"
  language="py"
/>
</TabItem>
</Tabs>

### <i class="fa-solid fa-code"></i>&nbsp;&nbsp;Set & configure the vectorizer

For this example, we will obtain our object vectors using an inference service. So to do that, we must set the `vectorizer` for the class. We'll use `text2vec-openai` in this case, and we can configure the module also at the class-level.

<Tabs groupId="languages">
<TabItem value="py" label="Python">
<FilteredTextBlock
  text={PythonCodeExample}
  startMarker="# Specify a vectorizer"
  endMarker="# End schema"
  language="py"
/>
</TabItem>
</Tabs>

### <i class="fa-solid fa-chalkboard"></i>&nbsp;&nbsp;Skipping a property from vectorization

You might have noticed the property-level module configuration here:

<Tabs groupId="languages">
<TabItem value="py" label="Python">
<FilteredTextBlock
  text={PythonCodeExample}
  startMarker="# Property-level module configuration for `round`"
  endMarker="# End of property-level module configuration"
  language="py"
/>
</TabItem>
</Tabs>

This configuration will exclude the `round` property from the vectorized text. You might be asking - why might we choose to do this?

Well, the answer is that whether the question belonged to "Jeopardy!", or "Double Jeopardy!" rounds simply do not add much to impact its meaning. You know by now that the vectorizer creates a vector representation of the object. In case of a text object, Weaviate first combines the text data according to an internal set of rules and your configuration.

It is the combined text that is vectorized. So, the difference between vectorizing the `round` property and skipping it would be something like this:

```json
// If the property is vectorized
answer {answer_text} question {question_text} category {category_text}
```

Against:

```json
// If the property is skipped
answer {answer_text} question {question_text}
```

More specifically, something like the difference between:

```json
// If the property is vectorized
answer faint paint question any pigment on the wall so faded you can barely see it category double jeopardy!
```

Against:

```json
// If the property is skipped
answer faint paint question any pigment on the wall so faded you can barely see it
```

The additional information is not particularly significant in capturing the meaning of the quiz item, which is mainly in the question and answer, as well as perhaps the category (not yet used).

:::tip Skipping vectorization has no impact on filtering
Importantly, excluding the `round` column from vectorization will have no impact on our ability to filter the results based on the `round` value. So if you wanted to only search a set of `Double Jeopardy!` questions, you still can.
:::

### <i class="fa-solid fa-code"></i>&nbsp;&nbsp;Create the class

We can now add the class to the schema.

<Tabs groupId="languages">
<TabItem value="py" label="Python">
<FilteredTextBlock
  text={PythonCodeExample}
  startMarker="# Define the class"
  endMarker='# Retrieve "JeopardyQuestion" class schema'
  language="py"
/>
</TabItem>
</Tabs>

Now, you can check that the class has been created successfully by retrieving its schema:

<Tabs groupId="languages">
<TabItem value="py" label="Python">
<FilteredTextBlock
  text={PythonCodeExample}
  startMarker='# Retrieve "JeopardyQuestion" class schema'
  endMarker="# Test class addition"
  language="py"
/>
</TabItem>
</Tabs>

:::note There's still quite a few more details!
See that the retrieved schema still has quite a few more details than we've seen! We'll cover many of those as we go.
:::

## <i class="fa-solid fa-square-chevron-right"></i>&nbsp;&nbsp;Import data

## <i class="fa-solid fa-square-chevron-right"></i>&nbsp;&nbsp;Review

### <i class="fa-solid fa-pen-to-square"></i>&nbsp;&nbsp;Review exercise

:::caution TODO
Add review exercises
:::

### <i class="fa-solid fa-lightbulb-on"></i>&nbsp;&nbsp;Key takeaways

import { GiscusDocComment } from '/src/components/GiscusComment';

<GiscusDocComment />